<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RespEncoders.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RedRadishes Core</a> &gt; <a href="index.source.html" class="el_package">redradishes.encoder</a> &gt; <span class="el_source">RespEncoders.java</span></div><h1>RespEncoders.java</h1><pre class="source lang-java linenums">package redradishes.encoder;

import com.google.common.base.Utf8;
import redradishes.UncheckedCharacterCodingException;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

import static java.nio.charset.StandardCharsets.US_ASCII;
import static java.nio.charset.StandardCharsets.UTF_8;
import static redradishes.encoder.ConstExpr.NEW_ARG;
import static redradishes.encoder.ConstExpr.byteConst;
import static redradishes.encoder.ConstExpr.bytesConst;
import static redradishes.encoder.Encoder.bytesEnc;
import static redradishes.encoder.Encoder.stringEnc;
import static redradishes.encoder.IntEncoder.digitEncoder;

<span class="nc" id="L26">public class RespEncoders {</span>
<span class="fc" id="L27">  private static final byte[][] NUM_BYTES =</span>
<span class="fc" id="L28">      IntStream.rangeClosed(10, 99).mapToObj(i -&gt; Integer.toString(i).getBytes(US_ASCII)).toArray(byte[][]::new);</span>
<span class="fc" id="L29">  private static final byte[] MIN_LONG_BYTES = &quot;-9223372036854775808&quot;.getBytes(US_ASCII);</span>
<span class="fc" id="L30">  private static final long[] SIZE_TABLE = LongStream.iterate(10, x -&gt; x * 10).limit(18).map(x -&gt; x - 1).toArray();</span>
<span class="fc" id="L31">  private static final ConstExpr CR_LF = bytesConst(new byte[]{'\r', '\n'});</span>
<span class="fc" id="L32">  private static final ConstExpr MIN_LONG_BULK_STRING =</span>
<span class="fc" id="L33">      charConst('2').append(charConst('0')).append(CR_LF).append(bytesConst(MIN_LONG_BYTES)).compact();</span>
<span class="fc" id="L34">  private static final ConstExpr EMPTY_BULK_STRING = charConst('0').append(CR_LF).compact();</span>
<span class="fc" id="L35">  private static final IntEncoder ONE_DIGIT_AS_BULK_STRING = charConst('1').append(CR_LF).append(digitEncoder());</span>
<span class="fc" id="L36">  private static final IntEncoder TWO_DIGITS_AS_BULK_STRING =</span>
<span class="fc" id="L37">      charConst('2').append(CR_LF).append(bytesEnc().mapToIntEncoder(num -&gt; NUM_BYTES[num - 10]));</span>
<span class="fc" id="L38">  private static final IntEncoder ARRAY = charConst('*').append(intEnc()).append(CR_LF).compact();</span>
<span class="fc" id="L39">  private static final ThreadLocal&lt;Map&lt;Charset, CharsetEncoder&gt;&gt; charsetDecodersMap =</span>
<span class="fc" id="L40">      new ThreadLocal&lt;Map&lt;Charset, CharsetEncoder&gt;&gt;() {</span>
        @Override
        protected Map&lt;Charset, CharsetEncoder&gt; initialValue() {
<span class="fc" id="L43">          return new WeakHashMap&lt;&gt;();</span>
        }
      };

  public static IntEncoder array() {
<span class="fc" id="L48">    return ARRAY;</span>
  }

  private static ConstExpr charConst(char c) {
<span class="fc" id="L52">    return byteConst((byte) c);</span>
  }

  public static Encoder&lt;CharSequence&gt; strBulkString(Charset charset) {
<span class="fc bfc" id="L56" title="All 2 branches covered.">    if (UTF_8.equals(charset)) {</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">      return NEW_ARG.append(Encoder.choiceConst(s -&gt; s.length() == 0, EMPTY_BULK_STRING,</span>
<span class="fc" id="L58">          intEnc().map(Utf8::encodedLength).append(CR_LF).zip(stringEnc(charset)))).append(CR_LF);</span>
    } else {
<span class="fc" id="L60">      CharsetEncoder charsetEncoder = getCharsetEncoder(charset);</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">      if (charsetEncoder.maxBytesPerChar() == 1.0) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        return NEW_ARG.append(Encoder.choiceConst(s -&gt; s.length() == 0, EMPTY_BULK_STRING,</span>
<span class="fc" id="L63">            intEnc().map(CharSequence::length).append(CR_LF).zip(stringEnc(charset)))).append(CR_LF);</span>
      } else {
<span class="fc" id="L65">        return NEW_ARG.append((Encoder&lt;CharSequence&gt;) s -&gt; {</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">          if (s.length() == 0) {</span>
<span class="fc" id="L67">            return EMPTY_BULK_STRING;</span>
          } else {
            try {
<span class="fc" id="L70">              ByteBuffer byteBuffer = encodeCharSeq(s, charsetEncoder);</span>
<span class="fc" id="L71">              int encodedLength = byteBuffer.remaining();</span>
<span class="fc" id="L72">              return intEnc().encode(encodedLength).append(CR_LF)</span>
<span class="fc" id="L73">                  .append(bytesConst(byteBuffer.array(), 0, encodedLength));</span>
<span class="nc" id="L74">            } catch (CharacterCodingException e) {</span>
<span class="nc" id="L75">              throw new UncheckedCharacterCodingException(e);</span>
            }
          }
<span class="fc" id="L78">        }).append(CR_LF);</span>
      }
    }
  }

  static CharsetEncoder getCharsetEncoder(Charset charset) {
<span class="fc" id="L84">    return charsetDecodersMap.get().computeIfAbsent(charset, Charset::newEncoder);</span>
  }

  private static ByteBuffer encodeCharSeq(CharSequence s, CharsetEncoder charsetEncoder)
      throws CharacterCodingException {
<span class="fc" id="L89">    int maxLength = (int) (s.length() * (double) charsetEncoder.maxBytesPerChar());</span>
<span class="fc" id="L90">    ByteBuffer byteBuffer = ByteBuffer.allocate(maxLength);</span>
<span class="fc" id="L91">    CharBuffer charBuffer = CharBuffer.wrap(s);</span>
<span class="fc" id="L92">    CoderResult coderResult = charsetEncoder.reset().encode(charBuffer, byteBuffer, true);</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">    if (coderResult.isUnderflow()) {</span>
<span class="fc" id="L94">      coderResult = charsetEncoder.flush(byteBuffer);</span>
    }
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">    if (!coderResult.isUnderflow()) {</span>
<span class="nc" id="L97">      coderResult.throwException();</span>
    }
<span class="fc" id="L99">    byteBuffer.flip();</span>
<span class="fc" id="L100">    return byteBuffer;</span>
  }

  public static Encoder&lt;byte[]&gt; bytesBulkString() {
<span class="fc" id="L104">    return NEW_ARG.append(arrayLenEnc()).append(CR_LF).zip(bytesEnc()).append(CR_LF);</span>
  }

  private static Encoder&lt;byte[]&gt; arrayLenEnc() {
<span class="fc" id="L108">    return intEnc().map(arr -&gt; arr.length);</span>
  }

  public static Encoder&lt;Integer&gt; intBulkString() {
<span class="fc bfc" id="L112" title="All 4 branches covered.">    return NEW_ARG.append(IntEncoder.choice(num -&gt; num &gt;= 0 &amp;&amp; num &lt;= 9, ONE_DIGIT_AS_BULK_STRING, IntEncoder</span>
<span class="fc bfc" id="L113" title="All 4 branches covered.">        .choice(num -&gt; num &gt;= 10 &amp;&amp; num &lt;= 99, TWO_DIGITS_AS_BULK_STRING,</span>
<span class="fc" id="L114">            longAsBulkString().mapToIntEncoder(Long::valueOf))).map(Integer::intValue)).append(CR_LF);</span>
  }

  public static Encoder&lt;Long&gt; longBulkString() {
<span class="fc bfc" id="L118" title="All 4 branches covered.">    return NEW_ARG.append(Encoder.choice(num -&gt; num &gt;= 0 &amp;&amp; num &lt;= 9, ONE_DIGIT_AS_BULK_STRING.map(Long::intValue),</span>
<span class="fc bfc" id="L119" title="All 4 branches covered.">        Encoder.choice(num -&gt; num &gt;= 10 &amp;&amp; num &lt;= 99, TWO_DIGITS_AS_BULK_STRING.map(Long::intValue),</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            Encoder.choiceConst(num -&gt; num == Long.MIN_VALUE, MIN_LONG_BULK_STRING, longAsBulkString()))))</span>
<span class="fc" id="L121">        .append(CR_LF);</span>
  }

  private static Encoder&lt;Long&gt; longAsBulkString() {
<span class="fc" id="L125">    return num -&gt; {</span>
<span class="fc" id="L126">      byte[] bytes = toBytes(num);</span>
<span class="fc" id="L127">      int len = bytes.length;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">      return (len &lt;= 9 ? byteConst((byte) ('0' + len)) : bytesConst(NUM_BYTES[len - 10])).append(CR_LF)</span>
<span class="fc" id="L129">          .append(bytesConst(bytes));</span>
    };
  }

  private static IntEncoder intEnc() {
<span class="fc" id="L134">    return num -&gt; {</span>
<span class="fc bfc" id="L135" title="All 4 branches covered.">      if (num &gt;= 0 &amp;&amp; num &lt;= 9) {</span>
<span class="fc" id="L136">        return byteConst((byte) ('0' + num));</span>
<span class="fc bfc" id="L137" title="All 4 branches covered.">      } else if (num &gt;= 10 &amp;&amp; num &lt;= 99) {</span>
<span class="fc" id="L138">        return bytesConst(NUM_BYTES[num - 10]);</span>
      }
<span class="fc" id="L140">      return bytesConst(toBytes(num));</span>
    };
  }

  static byte[] toBytes(long num) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    if (num == Long.MIN_VALUE) return MIN_LONG_BYTES;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">    boolean neg = num &lt; 0;</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">    if (neg) {</span>
<span class="fc" id="L148">      num = -num;</span>
    }
<span class="fc bfc" id="L150" title="All 2 branches covered.">    int size = neg ? stringSize(num) + 1 : stringSize(num);</span>
<span class="fc" id="L151">    byte[] buf = new byte[size];</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (neg) {</span>
<span class="fc" id="L153">      buf[0] = '-';</span>
    }
<span class="fc" id="L155">    int i = size - 1;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    while (num != 0) {</span>
<span class="fc" id="L157">      buf[i--] = (byte) ('0' + num % 10);</span>
<span class="fc" id="L158">      num /= 10;</span>
    }
<span class="fc" id="L160">    return buf;</span>
  }

  private static int stringSize(long x) {
<span class="fc bfc" id="L164" title="All 2 branches covered.">    for (int i = 0; i &lt; SIZE_TABLE.length; i++) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">      if (x &lt;= SIZE_TABLE[i]) {</span>
<span class="fc" id="L166">        return i + 1;</span>
      }
    }
<span class="fc" id="L169">    return 19;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>